#!/usr/bin/env node
/**
 * Comprehensive test coverage analyzer
 * Identifies all functions, methods, and components that need tests
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = path.join(__dirname, '../src');
const REPORT_DIR = path.join(__dirname, '../reports');

if (!fs.existsSync(REPORT_DIR)) {
  fs.mkdirSync(REPORT_DIR, { recursive: true });
}

function getAllSourceFiles(dir, fileList = [], baseDir = dir) {
  if (!fs.existsSync(dir)) return fileList;
  
  const files = fs.readdirSync(dir);
  
  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      if (
        !file.includes('node_modules') &&
        !file.includes('__tests__') &&
        !file.includes('__fixtures__') &&
        !file.includes('coverage') &&
        !file.includes('dist')
      ) {
        getAllSourceFiles(filePath, fileList, baseDir);
      }
    } else if (
      (file.endsWith('.ts') || file.endsWith('.tsx')) &&
      !file.endsWith('.test.ts') &&
      !file.endsWith('.test.tsx') &&
      !file.endsWith('.spec.ts') &&
      !file.endsWith('.spec.tsx') &&
      !file.endsWith('.d.ts')
    ) {
      fileList.push(filePath);
    }
  });
  
  return fileList;
}

function hasTestFile(sourcePath) {
  const dir = path.dirname(sourcePath);
  const baseName = path.basename(sourcePath, path.extname(sourcePath));
  const testPatterns = [
    path.join(dir, '__tests__', `${baseName}.test.ts`),
    path.join(dir, '__tests__', `${baseName}.test.tsx`),
    path.join(dir, `${baseName}.test.ts`),
    path.join(dir, `${baseName}.test.tsx`),
  ];
  
  return testPatterns.some((testPath) => fs.existsSync(testPath));
}

function extractExports(content, filePath) {
  const exports = [];
  const lines = content.split('\n');
  
  // Match various export patterns
  const patterns = [
    /^export\s+(?:default\s+)?(?:async\s+)?function\s+(\w+)/gm,
    /^export\s+const\s+(\w+)\s*=/gm,
    /^export\s+class\s+(\w+)/gm,
    /^export\s+(?:default\s+)?\{\s*([^}]+)\}/gm,
    /^(?:export\s+)?(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*(?:=>|{)/gm,
  ];
  
  patterns.forEach((pattern) => {
    let match;
    while ((match = pattern.exec(content)) !== null) {
      if (match[1] && !match[1].includes('type') && !match[1].includes('interface')) {
        exports.push({
          name: match[1].trim(),
          line: content.substring(0, match.index).split('\n').length,
        });
      }
    }
  });
  
  return exports;
}

function main() {
  console.log('Analyzing test coverage...\n');
  
  const allFiles = getAllSourceFiles(SRC_DIR);
  const report = {
    totalSourceFiles: allFiles.length,
    filesWithTests: 0,
    filesWithoutTests: 0,
    missingTests: [],
    byCategory: {
      services: [],
      hooks: [],
      components: [],
      screens: [],
      utils: [],
      others: [],
    },
  };
  
  allFiles.forEach((filePath) => {
    const relativePath = path.relative(SRC_DIR, filePath);
    const hasTest = hasTestFile(filePath);
    
    if (hasTest) {
      report.filesWithTests++;
    } else {
      report.filesWithoutTests++;
      
      const content = fs.readFileSync(filePath, 'utf-8');
      const exports = extractExports(content, filePath);
      
      const entry = {
        file: relativePath,
        fullPath: filePath,
        exports: exports,
        exportCount: exports.length,
      };
      
      report.missingTests.push(entry);
      
      // Categorize
      if (relativePath.includes('/services/')) {
        report.byCategory.services.push(entry);
      } else if (relativePath.includes('/hooks/')) {
        report.byCategory.hooks.push(entry);
      } else if (relativePath.includes('/components/')) {
        report.byCategory.components.push matter);
      } else if (relativePath.includes('/screens/')) {
        report.byCategory.screens.push(entry);
      } else if (relativePath.includes('/utils/')) {
        report.byCategory.utils.push(entry);
      } else {
        report.byCategory.others.push(entry);
      }
    }
  });
  
  // Write report
  const reportPath = path.join(REPORT_DIR, 'test-coverage-analysis.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  
  // Write summary
  const summaryPath = path.join(REPORT_DIR, 'test-coverage-summary.txt');
  const summary = `
TEST COVERAGE ANALYSIS SUMMARY
==============================

Total Source Files: ${report.totalSourceFiles}
Files With Tests: ${report.filesWithTests} (${Math.round((report.filesWithTests / report.totalSourceFiles) * 100)}%)
Files Without Tests: ${report.filesWithoutTests} (${Math.round((report.filesWithoutTests / report.totalSourceFiles) * 100)}%)

BREAKDOWN BY CATEGORY:
- Services: ${report.byCategory.services.length} files need tests
- Hooks: ${report.byCategory.hooks.length} files need tests
- Components: ${report.byCategory.components.length} files need tests
- Screens: ${report.byCategory.screens.length} files need tests
- Utils: ${report.byCategory.utils.length} files need tests
- Others: ${report.byCategory.others.length} files need tests

TOP 20 FILES NEEDING TESTS (by export count):
${report.missingTests
  .sort((a, b) => b.exportCount - a.exportCount)
  .slice(0, 20)
  .map((entry, i) => `${i + 1}. ${entry.file} (${entry.exportCount} exports)`)
  .join('\n')}

Full report saved to: ${reportPath}
`;
  
  fs.writeFileSync(summaryPath, summary);
  console.log(summary);
  
  return report;
}

main();

